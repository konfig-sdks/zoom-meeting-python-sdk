# coding: utf-8

"""
    Zoom Meeting API

    The Zoom Meeting APIs let developers to access information from Zoom. 

    The version of the OpenAPI document: 2
    Created by: https://developer.zoom.us/
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from zoom_meeting_python_sdk import schemas  # noqa: F401


class DevicesUpgradeZpaOsAppRequest(
    schemas.DictSchema
):
    """
    This class is auto generated by Konfig (https://konfigthis.com)
    """


    class MetaOapg:
        required = {
            "zdm_group_id",
            "data",
        }
        
        class properties:
            zdm_group_id = schemas.StrSchema
            
            
            class data(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    
                    class one_of_0(
                        schemas.DictSchema
                    ):
                    
                    
                        class MetaOapg:
                            required = {
                                "upgrade_type",
                            }
                            
                            class properties:
                                
                                
                                class firmware_versions(
                                    schemas.ListSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        
                                        
                                        class items(
                                            schemas.DictSchema
                                        ):
                                        
                                        
                                            class MetaOapg:
                                                
                                                class properties:
                                                    version = schemas.StrSchema
                                                    vendor = schemas.StrSchema
                                                    model = schemas.StrSchema
                                                    __annotations__ = {
                                                        "version": version,
                                                        "vendor": vendor,
                                                        "model": model,
                                                    }
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["version"]) -> MetaOapg.properties.version: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["vendor"]) -> MetaOapg.properties.vendor: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
                                            
                                            @typing.overload
                                            def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                                            
                                            def __getitem__(self, name: typing.Union[typing_extensions.Literal["version", "vendor", "model", ], str]):
                                                # dict_instance[name] accessor
                                                return super().__getitem__(name)
                                            
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["version"]) -> typing.Union[MetaOapg.properties.version, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["vendor"]) -> typing.Union[MetaOapg.properties.vendor, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> typing.Union[MetaOapg.properties.model, schemas.Unset]: ...
                                            
                                            @typing.overload
                                            def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                                            
                                            def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["version", "vendor", "model", ], str]):
                                                return super().get_item_oapg(name)
                                            
                                        
                                            def __new__(
                                                cls,
                                                *args: typing.Union[dict, frozendict.frozendict, ],
                                                version: typing.Union[MetaOapg.properties.version, str, schemas.Unset] = schemas.unset,
                                                vendor: typing.Union[MetaOapg.properties.vendor, str, schemas.Unset] = schemas.unset,
                                                model: typing.Union[MetaOapg.properties.model, str, schemas.Unset] = schemas.unset,
                                                _configuration: typing.Optional[schemas.Configuration] = None,
                                                **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                                            ) -> 'items':
                                                return super().__new__(
                                                    cls,
                                                    *args,
                                                    version=version,
                                                    vendor=vendor,
                                                    model=model,
                                                    _configuration=_configuration,
                                                    **kwargs,
                                                )
                                
                                    def __new__(
                                        cls,
                                        arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, ]]],
                                        _configuration: typing.Optional[schemas.Configuration] = None,
                                    ) -> 'firmware_versions':
                                        return super().__new__(
                                            cls,
                                            arg,
                                            _configuration=_configuration,
                                        )
                                
                                    def __getitem__(self, i: int) -> MetaOapg.items:
                                        return super().__getitem__(i)
                                
                                
                                class upgrade_type(
                                    schemas.EnumBase,
                                    schemas.StrSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        enum_value_to_name = {
                                            "UPGRADE_FIRMWARE": "UPGRADE_FIRMWARE",
                                        }
                                    
                                    @schemas.classproperty
                                    def UPGRADE_FIRMWARE(cls):
                                        return cls("UPGRADE_FIRMWARE")
                                __annotations__ = {
                                    "firmware_versions": firmware_versions,
                                    "upgrade_type": upgrade_type,
                                }
                        
                        upgrade_type: MetaOapg.properties.upgrade_type
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["firmware_versions"]) -> MetaOapg.properties.firmware_versions: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["upgrade_type"]) -> MetaOapg.properties.upgrade_type: ...
                        
                        @typing.overload
                        def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                        
                        def __getitem__(self, name: typing.Union[typing_extensions.Literal["firmware_versions", "upgrade_type", ], str]):
                            # dict_instance[name] accessor
                            return super().__getitem__(name)
                        
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["firmware_versions"]) -> typing.Union[MetaOapg.properties.firmware_versions, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["upgrade_type"]) -> MetaOapg.properties.upgrade_type: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                        
                        def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["firmware_versions", "upgrade_type", ], str]):
                            return super().get_item_oapg(name)
                        
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, ],
                            upgrade_type: typing.Union[MetaOapg.properties.upgrade_type, str, ],
                            firmware_versions: typing.Union[MetaOapg.properties.firmware_versions, list, tuple, schemas.Unset] = schemas.unset,
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'one_of_0':
                            return super().__new__(
                                cls,
                                *args,
                                upgrade_type=upgrade_type,
                                firmware_versions=firmware_versions,
                                _configuration=_configuration,
                                **kwargs,
                            )
                    
                    
                    class one_of_1(
                        schemas.DictSchema
                    ):
                    
                    
                        class MetaOapg:
                            required = {
                                "upgrade_type",
                            }
                            
                            class properties:
                                app_version = schemas.StrSchema
                                
                                
                                class upgrade_type(
                                    schemas.EnumBase,
                                    schemas.StrSchema
                                ):
                                
                                
                                    class MetaOapg:
                                        enum_value_to_name = {
                                            "UPGRADE_APP": "UPGRADE_APP",
                                        }
                                    
                                    @schemas.classproperty
                                    def UPGRADE_APP(cls):
                                        return cls("UPGRADE_APP")
                                __annotations__ = {
                                    "app_version": app_version,
                                    "upgrade_type": upgrade_type,
                                }
                        
                        upgrade_type: MetaOapg.properties.upgrade_type
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["app_version"]) -> MetaOapg.properties.app_version: ...
                        
                        @typing.overload
                        def __getitem__(self, name: typing_extensions.Literal["upgrade_type"]) -> MetaOapg.properties.upgrade_type: ...
                        
                        @typing.overload
                        def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
                        
                        def __getitem__(self, name: typing.Union[typing_extensions.Literal["app_version", "upgrade_type", ], str]):
                            # dict_instance[name] accessor
                            return super().__getitem__(name)
                        
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["app_version"]) -> typing.Union[MetaOapg.properties.app_version, schemas.Unset]: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: typing_extensions.Literal["upgrade_type"]) -> MetaOapg.properties.upgrade_type: ...
                        
                        @typing.overload
                        def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
                        
                        def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["app_version", "upgrade_type", ], str]):
                            return super().get_item_oapg(name)
                        
                    
                        def __new__(
                            cls,
                            *args: typing.Union[dict, frozendict.frozendict, ],
                            upgrade_type: typing.Union[MetaOapg.properties.upgrade_type, str, ],
                            app_version: typing.Union[MetaOapg.properties.app_version, str, schemas.Unset] = schemas.unset,
                            _configuration: typing.Optional[schemas.Configuration] = None,
                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                        ) -> 'one_of_1':
                            return super().__new__(
                                cls,
                                *args,
                                upgrade_type=upgrade_type,
                                app_version=app_version,
                                _configuration=_configuration,
                                **kwargs,
                            )
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            cls.one_of_0,
                            cls.one_of_1,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'data':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            __annotations__ = {
                "zdm_group_id": zdm_group_id,
                "data": data,
            }
    
    zdm_group_id: MetaOapg.properties.zdm_group_id
    data: MetaOapg.properties.data
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["zdm_group_id"]) -> MetaOapg.properties.zdm_group_id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["zdm_group_id", "data", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["zdm_group_id"]) -> MetaOapg.properties.zdm_group_id: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["zdm_group_id", "data", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        zdm_group_id: typing.Union[MetaOapg.properties.zdm_group_id, str, ],
        data: typing.Union[MetaOapg.properties.data, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'DevicesUpgradeZpaOsAppRequest':
        return super().__new__(
            cls,
            *args,
            zdm_group_id=zdm_group_id,
            data=data,
            _configuration=_configuration,
            **kwargs,
        )
